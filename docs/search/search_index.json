{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Type-safe templating for the browser. Install npm install --save-dev j-templates Hello World import { Component } from 'j-templates'; import { div } from 'j-templates/DOM'; class HelloWorld extends Component { public Template() { return div({}, () => \"Hello world\"); } } var helloWorld = Component.ToFunction(\"hello-world\", null, HelloWorld); Component.Attach(document.body, hellowWorld({})); Resulting HTML <hello-world> <div>Hello world</div> </hello-world>","title":"Home"},{"location":"#install","text":"npm install --save-dev j-templates","title":"Install"},{"location":"#hello-world","text":"import { Component } from 'j-templates'; import { div } from 'j-templates/DOM'; class HelloWorld extends Component { public Template() { return div({}, () => \"Hello world\"); } } var helloWorld = Component.ToFunction(\"hello-world\", null, HelloWorld); Component.Attach(document.body, hellowWorld({}));","title":"Hello World"},{"location":"#resulting-html","text":"<hello-world> <div>Hello world</div> </hello-world>","title":"Resulting HTML"},{"location":"animation/","text":"Animations window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"animation\"); });","title":"Animation"},{"location":"animation/#animations","text":"window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"animation\"); });","title":"Animations"},{"location":"components/","text":"Components This example shows how to reference one Component from another Component window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"componentsEx\"); }); The call to Component.ToFunction(...) returns a reusable Component function. Calling this function returns a ComponentNode<D, T, E> which is a child of NodeRef . Component functions take two parameters: a component definition object and a template definition object. The full signature is: component<D, T, E>(nodeDef: ComponentNodeFunctionParam<D, E>, templates?: T): NodeRef The three generic types D , T and E define types that can be passed from a parent component: D defines the type of data the component accepts. Data can be accessed in a component through the Data property. T defines templates the component accepts. This type is recommended to be of the form { [name: string]: {(...args: any[]): NodeRef | NodeRef[]} } . Templates can be referenced in a Component through the Templates property. E defines the events a Component supports as a JSON map. Events can be fired from a Component using the Fire(name: P extends keyof E, data?: E[P]) method. window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"componentsConfig\"); });","title":"Components"},{"location":"components/#components","text":"This example shows how to reference one Component from another Component window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"componentsEx\"); }); The call to Component.ToFunction(...) returns a reusable Component function. Calling this function returns a ComponentNode<D, T, E> which is a child of NodeRef . Component functions take two parameters: a component definition object and a template definition object. The full signature is: component<D, T, E>(nodeDef: ComponentNodeFunctionParam<D, E>, templates?: T): NodeRef The three generic types D , T and E define types that can be passed from a parent component: D defines the type of data the component accepts. Data can be accessed in a component through the Data property. T defines templates the component accepts. This type is recommended to be of the form { [name: string]: {(...args: any[]): NodeRef | NodeRef[]} } . Templates can be referenced in a Component through the Templates property. E defines the events a Component supports as a JSON map. Events can be fired from a Component using the Fire(name: P extends keyof E, data?: E[P]) method. window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"componentsConfig\"); });","title":"Components"},{"location":"decorators/","text":"window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"decorators\"); });","title":"Decorators"},{"location":"duplicateArray/","text":"Handling Duplicates in Arrays window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"duplicateArray\"); });","title":"Duplicate Array"},{"location":"duplicateArray/#handling-duplicates-in-arrays","text":"window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"duplicateArray\"); });","title":"Handling Duplicates in Arrays"},{"location":"dynamic/","text":"Dynamic Component window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"dynamic\"); }); Dynamic Component with Decorators window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"dynamicDecorators\"); });","title":"Dynamic Components"},{"location":"dynamic/#dynamic-component-with-decorators","text":"window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"dynamicDecorators\"); });","title":"Dynamic Component with Decorators"},{"location":"helloWorld/","text":"Hello World A basic hello world component. The code is editable and will re-execute after making changes. window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"helloWorld\", 35); }); Creating a new component is as simple as extending Component and overriding the Template() function. Template() flexible and returns NodeRef | NodeRef[] . window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"goodbyeWorld\", 70); }); Configuring a Node In the previous examples, span is an Element function that returns an ElementNode<T> which is a child of NodeRef . Element functions take two parameters: a node definition object and a child definition function. The full signature is: span<T>(nodeDef: ElementNodeFunctionParam<T>, children?: ElementChildrenFunction<T>): ElementNode<T> ElementNodeFunctionParam<T> is an object that defines properties, attributes, events and data T | T[] to bind the element to. ElementChildrenFunction<T> defines the child template for the node. It is a function that takes a single parameter T and returns NodeRef | NodeRef[] | string . window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"goodbyeWorldProps\", 70); }); Data Binding The data property of ElementNodeFunctionParam<T> takes a method with return type T | T[] . When binding to an array the child template binds to each element in the array. Binding to a falsy value is equivalent to binding to an empty array and results in no children. window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"goodbyeWorldData\", 70); });","title":"Hello World"},{"location":"helloWorld/#hello-world","text":"A basic hello world component. The code is editable and will re-execute after making changes. window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"helloWorld\", 35); }); Creating a new component is as simple as extending Component and overriding the Template() function. Template() flexible and returns NodeRef | NodeRef[] . window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"goodbyeWorld\", 70); });","title":"Hello World"},{"location":"helloWorld/#configuring-a-node","text":"In the previous examples, span is an Element function that returns an ElementNode<T> which is a child of NodeRef . Element functions take two parameters: a node definition object and a child definition function. The full signature is: span<T>(nodeDef: ElementNodeFunctionParam<T>, children?: ElementChildrenFunction<T>): ElementNode<T> ElementNodeFunctionParam<T> is an object that defines properties, attributes, events and data T | T[] to bind the element to. ElementChildrenFunction<T> defines the child template for the node. It is a function that takes a single parameter T and returns NodeRef | NodeRef[] | string . window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"goodbyeWorldProps\", 70); });","title":"Configuring a Node"},{"location":"helloWorld/#data-binding","text":"The data property of ElementNodeFunctionParam<T> takes a method with return type T | T[] . When binding to an array the child template binds to each element in the array. Binding to a falsy value is equivalent to binding to an empty array and results in no children. window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"goodbyeWorldData\", 70); });","title":"Data Binding"},{"location":"injectors/","text":"Injectors window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"injector\"); }); Injectors with Decorator window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"injectorDecorator\"); })","title":"Injector"},{"location":"injectors/#injectors","text":"window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"injector\"); });","title":"Injectors"},{"location":"injectors/#injectors-with-decorator","text":"window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"injectorDecorator\"); })","title":"Injectors with Decorator"},{"location":"stateManagement/","text":"State Management To implement dynamic state two store classes are provided: Store and StoreAsync . ObservableScope and ObservableScopeAsync are used to watch for changes to a store. Store Store is a synchronous JSON store. This store emits changes whether the state changed or not. Meant to be used for Component level state management. window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"storeBasic\", 70); }); StoreAsync StoreAsync is an asynchronous JSON store. All objects are stored by ID and a WebWorker is used to diff state changes. If the state doesn't change then the store doesn't emit. Meant to be used as a shared store across multiple Components. window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"storeAsyncBasic\", 70); }); store.Action Top level Store methods are wrappers for the store.Action method. This method allows for more granular updates to store objects and array operations. window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"storeActionBasic\"); });","title":"State Management"},{"location":"stateManagement/#state-management","text":"To implement dynamic state two store classes are provided: Store and StoreAsync . ObservableScope and ObservableScopeAsync are used to watch for changes to a store.","title":"State Management"},{"location":"stateManagement/#store","text":"Store is a synchronous JSON store. This store emits changes whether the state changed or not. Meant to be used for Component level state management. window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"storeBasic\", 70); });","title":"Store"},{"location":"stateManagement/#storeasync","text":"StoreAsync is an asynchronous JSON store. All objects are stored by ID and a WebWorker is used to diff state changes. If the state doesn't change then the store doesn't emit. Meant to be used as a shared store across multiple Components. window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"storeAsyncBasic\", 70); });","title":"StoreAsync"},{"location":"stateManagement/#storeaction","text":"Top level Store methods are wrappers for the store.Action method. This method allows for more granular updates to store objects and array operations. window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"storeActionBasic\"); });","title":"store.Action"},{"location":"tableTest/","text":"Table Test window.addEventListener('DOMContentLoaded', (event) => { CreateSample(\"tableTest\", 1080); });","title":"Table Test"}]}