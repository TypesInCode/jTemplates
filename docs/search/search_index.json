{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Type-safe templating for the browser.</p>"},{"location":"#install","title":"Install","text":"<pre><code>npm install --save-dev j-templates\n</code></pre>"},{"location":"#hello-world","title":"Hello World","text":"<pre><code>import { Component } from 'j-templates';\nimport { div } from 'j-templates/DOM';\n\nclass HelloWorld extends Component {\n\n    public Template() {\n        return div({}, () =&gt; \"Hello world\");\n    }\n\n}\n\nvar helloWorld = Component.ToFunction(\"hello-world\", null, HelloWorld);\nComponent.Attach(document.body, hellowWorld({}));\n</code></pre>"},{"location":"#resulting-html","title":"Resulting HTML","text":"<pre><code>&lt;hello-world&gt;\n    &lt;div&gt;Hello world&lt;/div&gt;\n&lt;/hello-world&gt;\n</code></pre>"},{"location":"animation/","title":"Animations","text":"window.addEventListener('DOMContentLoaded', (event) =&gt; {     CreateSample(\"animation\"); });"},{"location":"components/","title":"Components","text":"<p>This example shows how to reference one Component from another Component</p>     window.addEventListener('DOMContentLoaded', (event) =&gt; {     CreateSample(\"componentsEx\"); });  <p>The call to <code>Component.ToFunction(...)</code> returns a reusable Component function. Calling this function returns a <code>ComponentNode&lt;D, T, E&gt;</code> which is a child of <code>NodeRef</code>. Component functions take two parameters: a component definition object and a template definition object. The full signature is:</p> <pre><code>component&lt;D, T, E&gt;(nodeDef: ComponentNodeFunctionParam&lt;D, E&gt;, templates?: T): NodeRef\n</code></pre> <p>The three generic types <code>D</code>, <code>T</code> and <code>E</code> define types that can be passed from a parent component:</p> <ul> <li><code>D</code> defines the type of data the component accepts. Data can be accessed in a component through the <code>Data</code> property.  </li> <li><code>T</code> defines templates the component accepts. This type is recommended to be of the form <code>{ [name: string]: {(...args: any[]): NodeRef | NodeRef[]} }</code>. Templates can be referenced in a Component through the <code>Templates</code> property.  </li> <li><code>E</code> defines the events a Component supports as a JSON map. Events can be fired from a Component using the <code>Fire(name: P extends keyof E, data?: E[P])</code> method.  </li> </ul>    window.addEventListener('DOMContentLoaded', (event) =&gt; {     CreateSample(\"componentsConfig\"); });"},{"location":"decorators/","title":"Decorators","text":"window.addEventListener('DOMContentLoaded', (event) =&gt; {     CreateSample(\"decorators\"); });"},{"location":"duplicateArray/","title":"Handling Duplicates in Arrays","text":"window.addEventListener('DOMContentLoaded', (event) =&gt; {     CreateSample(\"duplicateArray\"); });"},{"location":"dynamic/","title":"Dynamic Components","text":"Dynamic Component    window.addEventListener('DOMContentLoaded', (event) =&gt; {     CreateSample(\"dynamic\"); });"},{"location":"dynamic/#dynamic-component-with-decorators","title":"Dynamic Component with Decorators","text":"window.addEventListener('DOMContentLoaded', (event) =&gt; {     CreateSample(\"dynamicDecorators\"); });"},{"location":"helloWorld/","title":"Hello World","text":"<p>A basic hello world component. The code is editable and will re-execute after making changes.</p>    <p>Creating a new component is as simple as extending <code>Component</code> and overriding the <code>Template()</code> function. <code>Template()</code> flexible and returns <code>NodeRef | NodeRef[]</code>.</p>    window.addEventListener('DOMContentLoaded', (event) =&gt; {     CreateSample(\"goodbyeWorld\", 70); });"},{"location":"helloWorld/#configuring-a-node","title":"Configuring a Node","text":"<p>In the previous examples, <code>span</code> is an Element function that returns an <code>ElementNode&lt;T&gt;</code> which is a child of <code>NodeRef</code>. Element functions take two parameters: a node definition object and a child definition function. The full signature is:</p> <pre><code>span&lt;T&gt;(nodeDef: ElementNodeFunctionParam&lt;T&gt;, children?: ElementChildrenFunction&lt;T&gt;): ElementNode&lt;T&gt;\n</code></pre> <p><code>ElementNodeFunctionParam&lt;T&gt;</code> is an object that defines properties, attributes, events and data <code>T | T[]</code> to bind the element to. <code>ElementChildrenFunction&lt;T&gt;</code> defines the child template for the node. It is a function that takes a single parameter <code>T</code> and returns <code>NodeRef | NodeRef[] | string</code>.</p>    window.addEventListener('DOMContentLoaded', (event) =&gt; {     CreateSample(\"goodbyeWorldProps\", 70); });"},{"location":"helloWorld/#data-binding","title":"Data Binding","text":"<p>The data property of <code>ElementNodeFunctionParam&lt;T&gt;</code> takes a method with return type <code>T | T[]</code>. When binding to an array the child template binds to each element in the array. Binding to a falsy value is equivalent to binding to an empty array and results in no children.</p>    window.addEventListener('DOMContentLoaded', (event) =&gt; {     CreateSample(\"goodbyeWorldData\", 70); });"},{"location":"injectors/","title":"Injector","text":""},{"location":"injectors/#injectors","title":"Injectors","text":"window.addEventListener('DOMContentLoaded', (event) =&gt; {     CreateSample(\"injector\"); });"},{"location":"injectors/#injectors-with-decorator","title":"Injectors with Decorator","text":"window.addEventListener('DOMContentLoaded', (event) =&gt; {     CreateSample(\"injectorDecorator\"); })"},{"location":"stateManagement/","title":"State Management","text":"<p>To implement dynamic state two store classes are provided: <code>Store</code> and <code>StoreAsync</code>. <code>ObservableScope</code> and <code>ObservableScopeAsync</code> are used to watch for changes to a store.</p>"},{"location":"stateManagement/#store","title":"Store","text":"<p><code>Store</code> is a synchronous JSON store. This store emits changes whether the state changed or not. Meant to be used for Component level state management.</p>"},{"location":"stateManagement/#storeasync","title":"StoreAsync","text":"<p><code>StoreAsync</code> is an asynchronous JSON store. All objects are stored by ID and a <code>WebWorker</code> is used to diff state changes. If the state doesn't change then the store doesn't emit. Meant to be used as a shared store across multiple Components.</p>    window.addEventListener('DOMContentLoaded', (event) =&gt; {     CreateSample(\"storeAsyncBasic\", 70); });"},{"location":"stateManagement/#storeaction","title":"store.Action","text":"<p>Top level Store methods are wrappers for the <code>store.Action</code> method. This method allows for more granular updates to store objects and array operations.</p>        window.addEventListener('DOMContentLoaded', (event) =&gt; {         CreateSample(\"storeActionBasic\");       });"},{"location":"tableTest/","title":"Table Test","text":"Table Test    window.addEventListener('DOMContentLoaded', (event) =&gt; {     CreateSample(\"tableTest\", 1080); });  Two Table Test    window.addEventListener('DOMContentLoaded', (event) =&gt; {     CreateSample(\"twoTableTest\", 1080); });"}]}